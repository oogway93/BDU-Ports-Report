package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"
)

type VulnerabilityInfo struct {
	CVEs  []CVEInfo
	MITRE []MITREInfo
	FSTEC []FSTECInfo
}

type CVEInfo struct {
	ID          string
	Description string
	Link        string
	Severity    string
}

type MITREInfo struct {
	ID          string
	Name        string
	Description string
	Link        string
	Tactic      string
}

type FSTECInfo struct {
	ID          string
	Title       string
	Description string
	Link        string
	Severity    string
}

func getVulnerabilityInfo(port int, service string) VulnerabilityInfo {
	return VulnerabilityInfo{
		CVEs:  getCVEsFromNVD(service),
		MITRE: getMITREFromATTACK(service),
		FSTEC: getFSTECFromBDU(service),
	}
}

func getCVEsFromNVD(service string) []CVEInfo {
	url := fmt.Sprintf("https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=%s&resultsPerPage=100", service)
	client := &http.Client{Timeout: 10 * time.Second}

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Printf("Ошибка создания запроса: %v", err)
		return mockCVEs(service)
	}

	// Добавляем User-Agent
	req.Header.Set("User-Agent", "PortScanner/1.0")

	resp, err := client.Do(req)
	if err != nil {
		log.Printf("Ошибка получения CVE: %v", err)
		return mockCVEs(service)
	}
	defer resp.Body.Close()

	// Проверяем код ответа
	if resp.StatusCode != http.StatusOK {
		log.Printf("Неверный статус ответа: %d", resp.StatusCode)
		return mockCVEs(service)
	}

	var result struct {
		Vulnerabilities []struct {
			CVE struct {
				ID          string `json:"id"`
				Description []struct {
					Lang  string `json:"lang"`
					Value string `json:"value"`
				} `json:"descriptions"`
				Metrics struct {
					CvssMetricV31 []struct {
						CvssData struct {
							BaseSeverenity string `json:"baseSeverity"`
						} `json:"cvssData"`
					} `json:"cvssMetricV31"`
				} `json:"metrics"`
			} `json:"cve"`
		} `json:"vulnerabilities"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		log.Printf("Ошибка декодирования CVE: %v", err)
		return mockCVEs(service)
	}

	var cves []CVEInfo
	for _, vuln := range result.Vulnerabilities {
		var description string
		for _, desc := range vuln.CVE.Description {
			if desc.Lang == "en" {
				description = desc.Value
				break
			}
		}
		if description == "" && len(vuln.CVE.Description) > 0 {
			description = vuln.CVE.Description[0].Value
		}

		// Разбиваем длинное описание на строки
		description = wrapText(description, 80)
		var severenity string
		if len(vuln.CVE.Metrics.CvssMetricV31) != 0 {
			severenity = vuln.CVE.Metrics.CvssMetricV31[0].CvssData.BaseSeverenity
		}

		if severenity == "HIGH" || severenity == "CRITICAL" {
			cves = append(cves, CVEInfo{
				ID:          vuln.CVE.ID,
				Description: description,
				Link:        fmt.Sprintf("https://nvd.nist.gov/vuln/detail/%s", vuln.CVE.ID),
				Severity:    severenity, // По умолчанию, так как в API нет информации о критичности
			})
		}
	}

	if len(cves) == 0 {
		return mockCVEs(service)
	}

	return cves
}

// mockCVEs возвращает тестовые данные CVE для сервиса
func mockCVEs(service string) []CVEInfo {
	return []CVEInfo{
		{
			ID:          "Нет данных",
			Description: fmt.Sprintf("Нет данных о %s", service),
			Link:        "Нет ссылки",
			Severity:    "Неизвестно",
		},
	}
}

func getMITREFromATTACK(service string) []MITREInfo {
	// Поскольку реальный API MITRE недоступен, возвращаем моковые данные
	mockData := []MITREInfo{
		{
			ID:          "T1190",
			Name:        "Эксплуатация публично доступного приложения",
			Description: wrapText(fmt.Sprintf("Злоумышленники могут попытаться воспользоваться уязвимостями сервиса %s для получения доступа.", service), 80),
			Link:        "https://attack.mitre.org/techniques/T1190",
			Tactic:      "Начальный доступ",
		},
		{
			ID:          "T1595",
			Name:        "Активное сканирование",
			Description: wrapText(fmt.Sprintf("Злоумышленники могут выполнять активное сканирование для сбора информации о сервисах %s.", service), 80),
			Link:        "https://attack.mitre.org/techniques/T1595",
			Tactic:      "Разведка",
		},
	}
	return mockData
}

func getFSTECFromBDU(service string) []FSTECInfo {
	// Поскольку API ФСТЭК БДУ недоступен, возвращаем моковые данные
	mockData := []FSTECInfo{
		{
			ID:          "BDU:2023-01234",
			Title:       fmt.Sprintf("Уязвимость сервиса %s", service),
			Description: wrapText(fmt.Sprintf("Уязвимость, связанная с некорректной обработкой входных данных в сервисе %s. Возможна удаленная эксплуатация.", service), 80),
			Link:        "https://bdu.fstec.ru/vul/2023-01234",
			Severity:    "Критический",
		},
		{
			ID:          "BDU:2023-05678",
			Title:       fmt.Sprintf("Недостаточная аутентификация в %s", service),
			Description: wrapText(fmt.Sprintf("Уязвимость, связанная с недостаточной проверкой аутентификации в сервисе %s. Возможен несанкционированный доступ.", service), 80),
			Link:        "https://bdu.fstec.ru/vul/2023-05678",
			Severity:    "Высокий",
		},
	}
	return mockData
}

// wrapText разбивает длинный текст на строки заданной длины
func wrapText(text string, width int) string {
	words := strings.Fields(text)
	if len(words) == 0 {
		return text
	}

	var lines []string
	currentLine := words[0]

	for _, word := range words[1:] {
		if len(currentLine)+1+len(word) <= width {
			currentLine += " " + word
		} else {
			lines = append(lines, currentLine)
			currentLine = word
		}
	}
	lines = append(lines, currentLine)

	return strings.Join(lines, "\n")
}
