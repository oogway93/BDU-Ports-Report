package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"
)

type VulnerabilityInfo struct {
	CVEs  []CVEInfo
	MITRE []MITREInfo
	FSTEC []FSTECInfo
}

type CVEInfo struct {
	ID          string
	Description string
	Link        string
	Severity    string
}

type MITREInfo struct {
	ID          string
	Name        string
	Description string
	Link        string
	Tactic      string
}

type FSTECInfo struct {
	ID          string
	Title       string
	Description string
	Link        string
	Severity    string
}

func getVulnerabilityInfo(port int, service string) VulnerabilityInfo {
	return VulnerabilityInfo{
		CVEs:  getCVEsFromNVD(service),
		MITRE: getMITREFromATTACK(service),
		FSTEC: getFSTECFromBDU(service),
	}
}

func getCVEsFromNVD(service string) []CVEInfo {
	url := fmt.Sprintf("https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch=%s&resultsPerPage=100", service)
	client := &http.Client{Timeout: 10 * time.Second}

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Printf("Error creating request: %v", err)
		return mockCVEs(service)
	}

	// Add User-Agent
	req.Header.Set("User-Agent", "PortScanner/1.0")

	resp, err := client.Do(req)
	if err != nil {
		log.Printf("Error getting CVEs: %v", err)
		return mockCVEs(service)
	}
	defer resp.Body.Close()

	// Check response status
	if resp.StatusCode != http.StatusOK {
		log.Printf("Invalid response status: %d", resp.StatusCode)
		return mockCVEs(service)
	}

	var result struct {
		Vulnerabilities []struct {
			CVE struct {
				ID          string `json:"id"`
				Description []struct {
					Lang  string `json:"lang"`
					Value string `json:"value"`
				} `json:"descriptions"`
				Metrics struct {
					CvssMetricV31 []struct {
						CvssData struct {
							BaseSeverenity string `json:"baseSeverity"`
						} `json:"cvssData"`
					} `json:"cvssMetricV31"`
				} `json:"metrics"`
			} `json:"cve"`
		} `json:"vulnerabilities"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		log.Printf("Error decoding CVEs: %v", err)
		return mockCVEs(service)
	}

	var cves []CVEInfo
	for _, vuln := range result.Vulnerabilities {
		var description string
		for _, desc := range vuln.CVE.Description {
			if desc.Lang == "en" {
				description = desc.Value
				break
			}
		}
		if description == "" && len(vuln.CVE.Description) > 0 {
			description = vuln.CVE.Description[0].Value
		}

		// Wrap long description text
		description = wrapText(description, 80)
		var severenity string
		if len(vuln.CVE.Metrics.CvssMetricV31) != 0 {
			severenity = vuln.CVE.Metrics.CvssMetricV31[0].CvssData.BaseSeverenity
		}

		if severenity == "HIGH" || severenity == "CRITICAL" {
			cves = append(cves, CVEInfo{
				ID:          vuln.CVE.ID,
				Description: description,
				Link:        fmt.Sprintf("https://nvd.nist.gov/vuln/detail/%s", vuln.CVE.ID),
				Severity:    severenity, // Default value as API doesn't provide criticality info
			})
		}
	}

	if len(cves) == 0 {
		return mockCVEs(service)
	}

	return cves
}

// mockCVEs returns test CVE data for the service
func mockCVEs(service string) []CVEInfo {
	return []CVEInfo{
		{
			ID:          "No data",
			Description: fmt.Sprintf("No data about %s", service),
			Link:        "No link",
			Severity:    "Unknown",
		},
	}
}

func getMITREFromATTACK(service string) []MITREInfo {
	// Since real MITRE API is not available, return mock data
	mockData := []MITREInfo{
		{
			ID:          "T1190",
			Name:        "Exploit Public-Facing Application",
			Description: wrapText(fmt.Sprintf("Attackers may try to exploit vulnerabilities in %s service to gain access.", service), 80),
			Link:        "https://attack.mitre.org/techniques/T1190",
			Tactic:      "Initial Access",
		},
		{
			ID:          "T1595",
			Name:        "Active Scanning",
			Description: wrapText(fmt.Sprintf("Attackers may perform active scanning to gather information about %s services.", service), 80),
			Link:        "https://attack.mitre.org/techniques/T1595",
			Tactic:      "Reconnaissance",
		},
	}
	return mockData
}

func getFSTECFromBDU(service string) []FSTECInfo {
	// Since FSTEC BDU API is not available, return mock data
	mockData := []FSTECInfo{
		{
			ID:          "BDU:2023-01234",
			Title:       fmt.Sprintf("Vulnerability in %s service", service),
			Description: wrapText(fmt.Sprintf("Vulnerability related to improper input processing in %s service. Remote exploitation possible.", service), 80),
			Link:        "https://bdu.fstec.ru/vul/2023-01234",
			Severity:    "Critical",
		},
		{
			ID:          "BDU:2023-05678",
			Title:       fmt.Sprintf("Insufficient authentication in %s", service),
			Description: wrapText(fmt.Sprintf("Vulnerability related to insufficient authentication checks in %s service. Unauthorized access possible.", service), 80),
			Link:        "https://bdu.fstec.ru/vul/2023-05678",
			Severity:    "High",
		},
	}
	return mockData
}

// wrapText wraps long text into lines of specified width
func wrapText(text string, width int) string {
	words := strings.Fields(text)
	if len(words) == 0 {
		return text
	}

	var lines []string
	currentLine := words[0]

	for _, word := range words[1:] {
		if len(currentLine)+1+len(word) <= width {
			currentLine += " " + word
		} else {
			lines = append(lines, currentLine)
			currentLine = word
		}
	}
	lines = append(lines, currentLine)

	return strings.Join(lines, "\n")
}
